precision highp float;
using namespace std;
#import <utils>

vec4 unpack16bitTexture(optional<std::Texture2d> positionHigh, optional<std::Texture2d> positionLow, vec2 uv)
{
    // vertex shader
    vec4 highSample = positionHigh.sampleLod(uv, 0.0).valueOr(vec4(.5, .5, .5, 1.));
    vec4 lowSample = positionLow.sampleLod(uv, 0.0).valueOr(vec4(.5, .5, .5, 1.));

    vec4 highByte = highSample * 255.0;
    vec4 lowByte = lowSample * 255.0;

    // Shift the high byte to the left by 8 bits and combine with the low byte
    vec4 reconstructedValue = highByte * 256.0 + lowByte;

    // normalize it to [0, 1] range
    return ((reconstructedValue / 65535.0) * 2.0 - 1.0);
}

export vec4 VATposition(optional<std::Texture2d> positionHigh, optional<std::Texture2d> positionLow, float frame) {
    // Attributes
    vec2 uv2 = getVertexTexCoord1().valueOr(vec2(0.0));

    // Calculate Position
    vec4 unpackedPos = unpack16bitTexture(positionHigh, positionLow, vec2(uv2 + vec2(0., frame-0.5)));
    vec4 yUpCoordinates = vec4(unpackedPos.x, -unpackedPos.y, unpackedPos.z, 1.0);
    return getModelViewProjectionMatrix() * (getVertexPosition() + yUpCoordinates);
}

export mat3 VATgetTangentFrame(optional<std::Texture2d> normalHigh, optional<std::Texture2d> normalLow, float frame) {
    // Attributes
    vec2 uv2 = getVertexTexCoord1().valueOr(vec2(0.0));

    // Calculate Tangent
    vec3 nrm = unpack16bitTexture(normalHigh, normalLow, vec2(uv2 + vec2(0., frame-0.5))).xyz;
    vec3 csTangent = mat3(getModelViewMatrix()) * getVertexTangent();
    vec3 csBitangent = cross(nrm, csTangent);
    return mat3(csTangent, csBitangent, nrm);
}

// @param[default=1.0] speed
// @return color
// @return position
void main(  optional<std::Texture2d> diffuse,
            optional<std::Texture2d> positionHigh,
            optional<std::Texture2d> positionLow,
            optional<std::Texture2d> normalHigh,
            optional<std::Texture2d> normalLow,
            optional<std::Texture2d> matcapTex,
            float speed,
            out vec4 Color,
            out vec4 Position)

{
  // Attributes
  vec2 uv = getVertexTexCoord();
  vec2 uv2 = getVertexTexCoord1().valueOr(vec2(0.0));

  float frame = mod(getTime()*speed,1.0);

  Position =  VATposition(positionHigh, positionLow, frame);

  // Calculate Tangent
  vec3 nrm = unpack16bitTexture(normalHigh, normalLow, vec2(uv2 + vec2(0., frame-0.5))).xyz;
  vec3 csTangent = mat3(getModelViewMatrix()) * getVertexTangent();
  vec3 csBitangent = cross(nrm, csTangent);
  mat3 csTangentFrame = mat3(csTangent, csBitangent, nrm);

  // fragment shader
  vec3 worldPosition = safeNormalize( vec3( getModelViewMatrix() * getVertexPosition() ) );
  // vec3 finalNormal = safeNormalize( getNormalMatrix() * getTangentFrame() * vec3(0.0,0.0,1.0) );
  vec3 finalNormal = safeNormalize( getNormalMatrix() * csTangentFrame * vec3(0.0,0.0,1.0) );

  vec3 r = reflect( worldPosition, finalNormal );
  float m = 2.0 * sqrt( r.x * r.x + r.y * r.y + ( r.z + 1.0 ) * ( r.z+1.0 ) );
  vec2 calculatedUV = vec2( r.x / m + 0.5,  1.0 - (r.y / m + 0.5) );

  float fresnel = pow(1.0 - dot(-worldPosition, finalNormal), 1.2);

  // float mixFactor = fresnel - (1. - AOTex.sample(uv).valueOr(vec4(1.0)).x);
  // vec4 basecolors = mix(color1, color2, mixFactor) + matcapTex.sample(calculatedUV).valueOr(vec4(0.0)) * matCapIntensity;
  // vec4 goldcolors = mix(goldcolor1, goldcolor2, mixFactor + matcapTex.sample(calculatedUV).valueOr(vec4(0.0)));

  Color = matcapTex.sample(calculatedUV).valueOr(vec4(0.0));
}
